// jquery.event.move
//
// 1.3.6
//
// Stephen Band
//
// Triggers 'movestart', 'move' and 'moveend' events after
// mousemoves following a mousedown cross a distance threshold,
// similar to the native 'dragstart', 'drag' and 'dragend' events.
// Move events are throttled to animation frames. Move event objects
// have the properties:
//
// pageX:
// pageY:   Page coordinates of pointer.
// startX:
// startY:  Page coordinates of pointer at movestart.
// distX:
// distY:  Distance the pointer has moved since movestart.
// deltaX:
// deltaY:  Distance the finger has moved since last event.
// velocityX:
// velocityY:  Average velocity over last few events.
!function(module) {
    "function" == typeof define && define.amd ? // AMD. Register as an anonymous module.
    define([ "jquery" ], module) : // Browser globals
    module(jQuery);
}(function(jQuery, undefined) {
    // Constructors
    function Timer(fn) {
        function trigger(time) {
            active ? (callback(), requestFrame(trigger), running = !0, 
            active = !1) : running = !1;
        }
        var callback = fn, active = !1, running = !1;
        this.kick = function(fn) {
            active = !0, running || trigger();
        }, this.end = function(fn) {
            var cb = callback;
            fn && (// If the timer is not running, simply call the end callback.
            running ? (callback = active ? function() {
                cb(), fn();
            } : fn, active = !0) : fn());
        };
    }
    // Functions
    function returnTrue() {
        return !0;
    }
    function returnFalse() {
        return !1;
    }
    function preventDefault(e) {
        e.preventDefault();
    }
    function preventIgnoreTags(e) {
        // Don't prevent interaction with form elements.
        ignoreTags[e.target.tagName.toLowerCase()] || e.preventDefault();
    }
    function isLeftButton(e) {
        // Ignore mousedowns on any button other than the left (or primary)
        // mouse button, or when a modifier key is pressed.
        return 1 === e.which && !e.ctrlKey && !e.altKey;
    }
    function identifiedTouch(touchList, id) {
        var i, l;
        if (touchList.identifiedTouch) return touchList.identifiedTouch(id);
        for (// touchList.identifiedTouch() does not exist in
        // webkit yetâ€¦ we must do the search ourselves...
        i = -1, l = touchList.length; ++i < l; ) if (touchList[i].identifier === id) return touchList[i];
    }
    function changedTouch(e, event) {
        var touch = identifiedTouch(e.changedTouches, event.identifier);
        // This isn't the touch you're looking for.
        if (touch && (touch.pageX !== event.pageX || touch.pageY !== event.pageY)) return touch;
    }
    // Handlers that decide when the first movestart is triggered
    function mousedown(e) {
        var data;
        isLeftButton(e) && (data = {
            target: e.target,
            startX: e.pageX,
            startY: e.pageY,
            timeStamp: e.timeStamp
        }, add(document, mouseevents.move, mousemove, data), 
        add(document, mouseevents.cancel, mouseend, data));
    }
    function mousemove(e) {
        var data = e.data;
        checkThreshold(e, data, e, removeMouse);
    }
    function mouseend(e) {
        removeMouse();
    }
    function removeMouse() {
        remove(document, mouseevents.move, mousemove), remove(document, mouseevents.cancel, mouseend);
    }
    function touchstart(e) {
        var touch, template;
        // Don't get in the way of interaction with form elements.
        ignoreTags[e.target.tagName.toLowerCase()] || (touch = e.changedTouches[0], 
        // iOS live updates the touch objects whereas Android gives us copies.
        // That means we can't trust the touchstart object to stay the same,
        // so we must copy the data. This object acts as a template for
        // movestart, move and moveend event objects.
        template = {
            target: touch.target,
            startX: touch.pageX,
            startY: touch.pageY,
            timeStamp: e.timeStamp,
            identifier: touch.identifier
        }, // Use the touch identifier as a namespace, so that we can later
        // remove handlers pertaining only to this touch.
        add(document, touchevents.move + "." + touch.identifier, touchmove, template), 
        add(document, touchevents.cancel + "." + touch.identifier, touchend, template));
    }
    function touchmove(e) {
        var data = e.data, touch = changedTouch(e, data);
        touch && checkThreshold(e, data, touch, removeTouch);
    }
    function touchend(e) {
        var template = e.data, touch = identifiedTouch(e.changedTouches, template.identifier);
        touch && removeTouch(template.identifier);
    }
    function removeTouch(identifier) {
        remove(document, "." + identifier, touchmove), remove(document, "." + identifier, touchend);
    }
    // Logic for deciding when to trigger a movestart.
    function checkThreshold(e, template, touch, fn) {
        var distX = touch.pageX - template.startX, distY = touch.pageY - template.startY;
        // Do nothing if the threshold has not been crossed.
        threshold * threshold > distX * distX + distY * distY || triggerStart(e, template, touch, distX, distY, fn);
    }
    function handled() {
        // this._handled should return false once, and after return true.
        return this._handled = returnTrue, !1;
    }
    function flagAsHandled(e) {
        e._handled();
    }
    function triggerStart(e, template, touch, distX, distY, fn) {
        var touches, time;
        template.target;
        touches = e.targetTouches, time = e.timeStamp - template.timeStamp, 
        // Create a movestart object with some special properties that
        // are passed only to the movestart handlers.
        template.type = "movestart", template.distX = distX, 
        template.distY = distY, template.deltaX = distX, template.deltaY = distY, 
        template.pageX = touch.pageX, template.pageY = touch.pageY, 
        template.velocityX = distX / time, template.velocityY = distY / time, 
        template.targetTouches = touches, template.finger = touches ? touches.length : 1, 
        // The _handled method is fired to tell the default movestart
        // handler that one of the move events is bound.
        template._handled = handled, // Pass the touchmove event so it can be prevented if or when
        // movestart is handled.
        template._preventTouchmoveDefault = function() {
            e.preventDefault();
        }, // Trigger the movestart event.
        trigger(template.target, template), // Unbind handlers that tracked the touch or mouse up till now.
        fn(template.identifier);
    }
    // Handlers that control what happens following a movestart
    function activeMousemove(e) {
        var timer = e.data.timer;
        e.data.touch = e, e.data.timeStamp = e.timeStamp, 
        timer.kick();
    }
    function activeMouseend(e) {
        var event = e.data.event, timer = e.data.timer;
        removeActiveMouse(), endEvent(event, timer, function() {
            // Unbind the click suppressor, waiting until after mouseup
            // has been handled.
            setTimeout(function() {
                remove(event.target, "click", returnFalse);
            }, 0);
        });
    }
    function removeActiveMouse(event) {
        remove(document, mouseevents.move, activeMousemove), 
        remove(document, mouseevents.end, activeMouseend);
    }
    function activeTouchmove(e) {
        var event = e.data.event, timer = e.data.timer, touch = changedTouch(e, event);
        touch && (// Stop the interface from gesturing
        e.preventDefault(), event.targetTouches = e.targetTouches, 
        e.data.touch = touch, e.data.timeStamp = e.timeStamp, 
        timer.kick());
    }
    function activeTouchend(e) {
        var event = e.data.event, timer = e.data.timer, touch = identifiedTouch(e.changedTouches, event.identifier);
        // This isn't the touch you're looking for.
        touch && (removeActiveTouch(event), endEvent(event, timer));
    }
    function removeActiveTouch(event) {
        remove(document, "." + event.identifier, activeTouchmove), 
        remove(document, "." + event.identifier, activeTouchend);
    }
    // Logic for triggering move and moveend events
    function updateEvent(event, touch, timeStamp, timer) {
        var time = timeStamp - event.timeStamp;
        event.type = "move", event.distX = touch.pageX - event.startX, 
        event.distY = touch.pageY - event.startY, event.deltaX = touch.pageX - event.pageX, 
        event.deltaY = touch.pageY - event.pageY, // Average the velocity of the last few events using a decay
        // curve to even out spurious jumps in values.
        event.velocityX = .3 * event.velocityX + .7 * event.deltaX / time, 
        event.velocityY = .3 * event.velocityY + .7 * event.deltaY / time, 
        event.pageX = touch.pageX, event.pageY = touch.pageY;
    }
    function endEvent(event, timer, fn) {
        timer.end(function() {
            return event.type = "moveend", trigger(event.target, event), 
            fn && fn();
        });
    }
    // jQuery special event definition
    function setup(data, namespaces, eventHandle) {
        // Don't bind to the DOM. For speed.
        // Stop the node from being dragged
        //add(this, 'dragstart.move drag.move', preventDefault);
        // Prevent text selection and touch interface scrolling
        //add(this, 'mousedown.move', preventIgnoreTags);
        // Tell movestart default handler that we've handled this
        return add(this, "movestart.move", flagAsHandled), 
        !0;
    }
    function teardown(namespaces) {
        // Don't bind to the DOM. For speed.
        return remove(this, "dragstart drag", preventDefault), 
        remove(this, "mousedown touchstart", preventIgnoreTags), 
        remove(this, "movestart", flagAsHandled), !0;
    }
    function addMethod(handleObj) {
        // We're not interested in preventing defaults for handlers that
        // come from internal move or moveend bindings
        "move" !== handleObj.namespace && "moveend" !== handleObj.namespace && (// Stop the node from being dragged
        add(this, "dragstart." + handleObj.guid + " drag." + handleObj.guid, preventDefault, undefined, handleObj.selector), 
        // Prevent text selection and touch interface scrolling
        add(this, "mousedown." + handleObj.guid, preventIgnoreTags, undefined, handleObj.selector));
    }
    function removeMethod(handleObj) {
        "move" !== handleObj.namespace && "moveend" !== handleObj.namespace && (remove(this, "dragstart." + handleObj.guid + " drag." + handleObj.guid), 
        remove(this, "mousedown." + handleObj.guid));
    }
    var // Number of pixels a pressed pointer travels before movestart
    // event is fired.
    threshold = 6, add = jQuery.event.add, remove = jQuery.event.remove, // Just sugar, so we can have arguments in the same order as
    // add and remove.
    trigger = function(node, type, data) {
        jQuery.event.trigger(type, data, node);
    }, // Shim for requestAnimationFrame, falling back to timer. See:
    // see http://paulirish.com/2011/requestanimationframe-for-smart-animating/
    requestFrame = function() {
        return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(fn, element) {
            return window.setTimeout(function() {
                fn();
            }, 25);
        };
    }(), ignoreTags = {
        textarea: !0,
        input: !0,
        select: !0,
        button: !0
    }, mouseevents = {
        move: "mousemove",
        cancel: "mouseup dragstart",
        end: "mouseup"
    }, touchevents = {
        move: "touchmove",
        cancel: "touchend",
        end: "touchend"
    };
    jQuery.event.special.movestart = {
        setup: setup,
        teardown: teardown,
        add: addMethod,
        remove: removeMethod,
        _default: function(e) {
            function update(time) {
                updateEvent(event, data.touch, data.timeStamp), trigger(e.target, event);
            }
            var event, data;
            // If no move events were bound to any ancestors of this
            // target, high tail it out of here.
            e._handled() && (event = {
                target: e.target,
                startX: e.startX,
                startY: e.startY,
                pageX: e.pageX,
                pageY: e.pageY,
                distX: e.distX,
                distY: e.distY,
                deltaX: e.deltaX,
                deltaY: e.deltaY,
                velocityX: e.velocityX,
                velocityY: e.velocityY,
                timeStamp: e.timeStamp,
                identifier: e.identifier,
                targetTouches: e.targetTouches,
                finger: e.finger
            }, data = {
                event: event,
                timer: new Timer(update),
                touch: undefined,
                timeStamp: undefined
            }, e.identifier === undefined ? (// We're dealing with a mouse
            // Stop clicks from propagating during a move
            add(e.target, "click", returnFalse), add(document, mouseevents.move, activeMousemove, data), 
            add(document, mouseevents.end, activeMouseend, data)) : (// We're dealing with a touch. Stop touchmove doing
            // anything defaulty.
            e._preventTouchmoveDefault(), add(document, touchevents.move + "." + e.identifier, activeTouchmove, data), 
            add(document, touchevents.end + "." + e.identifier, activeTouchend, data)));
        }
    }, jQuery.event.special.move = {
        setup: function() {
            // Bind a noop to movestart. Why? It's the movestart
            // setup that decides whether other move events are fired.
            add(this, "movestart.move", jQuery.noop);
        },
        teardown: function() {
            remove(this, "movestart.move", jQuery.noop);
        }
    }, jQuery.event.special.moveend = {
        setup: function() {
            // Bind a noop to movestart. Why? It's the movestart
            // setup that decides whether other move events are fired.
            add(this, "movestart.moveend", jQuery.noop);
        },
        teardown: function() {
            remove(this, "movestart.moveend", jQuery.noop);
        }
    }, add(document, "mousedown.move", mousedown), add(document, "touchstart.move", touchstart), 
    // Make jQuery copy touch event properties over to the jQuery event
    // object, if they are not already listed. But only do the ones we
    // really need. IE7/8 do not have Array#indexOf(), but nor do they
    // have touch events, so let's assume we can ignore them.
    "function" == typeof Array.prototype.indexOf && !function(jQuery, undefined) {
        for (var props = [ "changedTouches", "targetTouches" ], l = props.length; l--; ) -1 === jQuery.event.props.indexOf(props[l]) && jQuery.event.props.push(props[l]);
    }(jQuery);
}), /*!
 * Lightbox v2.8.2
 * by Lokesh Dhakar
 *
 * More info:
 * http://lokeshdhakar.com/projects/lightbox2/
 *
 * Copyright 2007, 2015 Lokesh Dhakar
 * Released under the MIT license
 * https://github.com/lokesh/lightbox2/blob/master/LICENSE
 */
// Uses Node, AMD or browser globals to create a module.
function(root, factory) {
    "function" == typeof define && define.amd ? // AMD. Register as an anonymous module.
    define([ "jquery" ], factory) : "object" == typeof exports ? // Node. Does not work with strict CommonJS, but
    // only CommonJS-like environments that support module.exports,
    // like Node.
    module.exports = factory(require("jquery")) : // Browser globals (root is window)
    root.lightbox = factory(root.jQuery);
}(this, function($) {
    function Lightbox(options) {
        this.album = [], this.currentImageIndex = void 0, 
        this.init(), // options
        this.options = $.extend({}, this.constructor.defaults), 
        this.option(options);
    }
    // Descriptions of all options available on the demo site:
    // http://lokeshdhakar.com/projects/lightbox2/index.html#options
    // Loop through anchors and areamaps looking for either data-lightbox attributes or rel attributes
    // that contain 'lightbox'. When these are clicked, start lightbox.
    // Build html for the lightbox and the overlay.
    // Attach event handlers to the new DOM elements. click click click
    // Show overlay and lightbox. If the image is part of a set, add siblings to album array.
    // Hide most UI elements in preparation for the animated resizing of the lightbox.
    // Stretch overlay to fit the viewport
    // Animate the size of the lightbox to fit the image we are showing
    // Display the image and its details and begin preload neighboring images.
    // Display previous and next navigation if appropriate.
    // Display caption, image number, and closing button.
    // Preload previous and next images in set.
    // Closing time. :-(
    return Lightbox.defaults = {
        albumLabel: "Image %1 of %2",
        alwaysShowNavOnTouchDevices: !1,
        fadeDuration: 500,
        fitImagesInViewport: !0,
        // maxWidth: 800,
        // maxHeight: 600,
        positionFromTop: 50,
        resizeDuration: 700,
        showImageNumberLabel: !0,
        wrapAround: !1,
        disableScrolling: !1
    }, Lightbox.prototype.option = function(options) {
        $.extend(this.options, options);
    }, Lightbox.prototype.imageCountLabel = function(currentImageNum, totalImages) {
        return this.options.albumLabel.replace(/%1/g, currentImageNum).replace(/%2/g, totalImages);
    }, Lightbox.prototype.init = function() {
        this.enable(), this.build();
    }, Lightbox.prototype.enable = function() {
        var self = this;
        $("body").on("click", "a[rel^=lightbox], area[rel^=lightbox], a[data-lightbox], area[data-lightbox]", function(event) {
            return self.start($(event.currentTarget)), !1;
        });
    }, Lightbox.prototype.build = function() {
        var self = this;
        $('<div id="lightboxOverlay" class="lightboxOverlay"></div><div id="lightbox" class="lightbox"><div class="lb-outerContainer"><div class="lb-container"><img class="lb-image" src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==" /><div class="lb-nav"><a class="lb-prev" href="" ></a><a class="lb-next" href="" ></a></div><div class="lb-loader"><a class="lb-cancel"></a></div></div></div><div class="lb-dataContainer"><div class="lb-data"><div class="lb-details"><span class="lb-caption"></span><span class="lb-number"></span></div><div class="lb-closeContainer"><a class="lb-close"></a></div></div></div></div>').appendTo($("body")), 
        // Cache jQuery objects
        this.$lightbox = $("#lightbox"), this.$overlay = $("#lightboxOverlay"), 
        this.$outerContainer = this.$lightbox.find(".lb-outerContainer"), 
        this.$container = this.$lightbox.find(".lb-container"), 
        // Store css values for future lookup
        this.containerTopPadding = parseInt(this.$container.css("padding-top"), 10), 
        this.containerRightPadding = parseInt(this.$container.css("padding-right"), 10), 
        this.containerBottomPadding = parseInt(this.$container.css("padding-bottom"), 10), 
        this.containerLeftPadding = parseInt(this.$container.css("padding-left"), 10), 
        // Attach event handlers to the newly minted DOM elements
        this.$overlay.hide().on("click", function() {
            return self.end(), !1;
        }), this.$lightbox.hide().on("click", function(event) {
            return "lightbox" === $(event.target).attr("id") && self.end(), 
            !1;
        }), this.$outerContainer.on("click", function(event) {
            return "lightbox" === $(event.target).attr("id") && self.end(), 
            !1;
        }), this.$lightbox.find(".lb-prev").on("click", function() {
            return 0 === self.currentImageIndex ? self.changeImage(self.album.length - 1) : self.changeImage(self.currentImageIndex - 1), 
            !1;
        }), this.$lightbox.find(".lb-next").on("click", function() {
            return self.currentImageIndex === self.album.length - 1 ? self.changeImage(0) : self.changeImage(self.currentImageIndex + 1), 
            !1;
        }), this.$lightbox.find(".lb-loader, .lb-close").on("click", function() {
            return self.end(), !1;
        });
    }, Lightbox.prototype.start = function($link) {
        function addToAlbum($link) {
            self.album.push({
                link: $link.attr("href"),
                title: $link.attr("data-title") || $link.attr("title")
            });
        }
        var self = this, $window = $(window);
        $window.on("resize", $.proxy(this.sizeOverlay, this)), 
        $("select, object, embed").css({
            visibility: "hidden"
        }), this.sizeOverlay(), this.album = [];
        var $links, imageNumber = 0, dataLightboxValue = $link.attr("data-lightbox");
        if (dataLightboxValue) {
            $links = $($link.prop("tagName") + '[data-lightbox="' + dataLightboxValue + '"]');
            for (var i = 0; i < $links.length; i = ++i) addToAlbum($($links[i])), 
            $links[i] === $link[0] && (imageNumber = i);
        } else if ("lightbox" === $link.attr("rel")) // If image is not part of a set
        addToAlbum($link); else {
            // If image is part of a set
            $links = $($link.prop("tagName") + '[rel="' + $link.attr("rel") + '"]');
            for (var j = 0; j < $links.length; j = ++j) addToAlbum($($links[j])), 
            $links[j] === $link[0] && (imageNumber = j);
        }
        // Position Lightbox
        var top = $window.scrollTop() + this.options.positionFromTop, left = $window.scrollLeft();
        this.$lightbox.css({
            top: top + "px",
            left: left + "px"
        }).fadeIn(this.options.fadeDuration), // Disable scrolling of the page while open
        this.options.disableScrolling && $("body").addClass("lb-disable-scrolling"), 
        this.changeImage(imageNumber);
    }, Lightbox.prototype.changeImage = function(imageNumber) {
        var self = this;
        this.disableKeyboardNav();
        var $image = this.$lightbox.find(".lb-image");
        this.$overlay.fadeIn(this.options.fadeDuration), $(".lb-loader").fadeIn("slow"), 
        this.$lightbox.find(".lb-image, .lb-nav, .lb-prev, .lb-next, .lb-dataContainer, .lb-numbers, .lb-caption").hide(), 
        this.$outerContainer.addClass("animating");
        // When image to show is preloaded, we send the width and height to sizeContainer()
        var preloader = new Image();
        preloader.onload = function() {
            var $preloader, imageHeight, imageWidth, maxImageHeight, maxImageWidth, windowHeight, windowWidth;
            $image.attr("src", self.album[imageNumber].link), 
            $preloader = $(preloader), $image.width(preloader.width), 
            $image.height(preloader.height), self.options.fitImagesInViewport && (// Fit image inside the viewport.
            // Take into account the border around the image and an additional 10px gutter on each side.
            windowWidth = $(window).width(), windowHeight = $(window).height(), 
            maxImageWidth = windowWidth - self.containerLeftPadding - self.containerRightPadding - 20, 
            maxImageHeight = windowHeight - self.containerTopPadding - self.containerBottomPadding - 120, 
            // Check if image size is larger then maxWidth|maxHeight in settings
            self.options.maxWidth && self.options.maxWidth < maxImageWidth && (maxImageWidth = self.options.maxWidth), 
            self.options.maxHeight && self.options.maxHeight < maxImageWidth && (maxImageHeight = self.options.maxHeight), 
            // Is there a fitting issue?
            (preloader.width > maxImageWidth || preloader.height > maxImageHeight) && (preloader.width / maxImageWidth > preloader.height / maxImageHeight ? (imageWidth = maxImageWidth, 
            imageHeight = parseInt(preloader.height / (preloader.width / imageWidth), 10), 
            $image.width(imageWidth), $image.height(imageHeight)) : (imageHeight = maxImageHeight, 
            imageWidth = parseInt(preloader.width / (preloader.height / imageHeight), 10), 
            $image.width(imageWidth), $image.height(imageHeight)))), 
            self.sizeContainer($image.width(), $image.height());
        }, preloader.src = this.album[imageNumber].link, this.currentImageIndex = imageNumber;
    }, Lightbox.prototype.sizeOverlay = function() {
        this.$overlay.width($(document).width()).height($(document).height());
    }, Lightbox.prototype.sizeContainer = function(imageWidth, imageHeight) {
        function postResize() {
            self.$lightbox.find(".lb-dataContainer").width(newWidth), 
            self.$lightbox.find(".lb-prevLink").height(newHeight), 
            self.$lightbox.find(".lb-nextLink").height(newHeight), 
            self.showImage();
        }
        var self = this, oldWidth = this.$outerContainer.outerWidth(), oldHeight = this.$outerContainer.outerHeight(), newWidth = imageWidth + this.containerLeftPadding + this.containerRightPadding, newHeight = imageHeight + this.containerTopPadding + this.containerBottomPadding;
        oldWidth !== newWidth || oldHeight !== newHeight ? this.$outerContainer.animate({
            width: newWidth,
            height: newHeight
        }, this.options.resizeDuration, "swing", function() {
            postResize();
        }) : postResize();
    }, Lightbox.prototype.showImage = function() {
        this.$lightbox.find(".lb-loader").stop(!0).hide(), 
        this.$lightbox.find(".lb-image").fadeIn("slow"), this.updateNav(), 
        this.updateDetails(), this.preloadNeighboringImages(), 
        this.enableKeyboardNav();
    }, Lightbox.prototype.updateNav = function() {
        // Check to see if the browser supports touch events. If so, we take the conservative approach
        // and assume that mouse hover events are not supported and always show prev/next navigation
        // arrows in image sets.
        var alwaysShowNav = !1;
        try {
            document.createEvent("TouchEvent"), alwaysShowNav = this.options.alwaysShowNavOnTouchDevices ? !0 : !1;
        } catch (e) {}
        this.$lightbox.find(".lb-nav").show(), this.album.length > 1 && (this.options.wrapAround ? (alwaysShowNav && this.$lightbox.find(".lb-prev, .lb-next").css("opacity", "1"), 
        this.$lightbox.find(".lb-prev, .lb-next").show()) : (this.currentImageIndex > 0 && (this.$lightbox.find(".lb-prev").show(), 
        alwaysShowNav && this.$lightbox.find(".lb-prev").css("opacity", "1")), 
        this.currentImageIndex < this.album.length - 1 && (this.$lightbox.find(".lb-next").show(), 
        alwaysShowNav && this.$lightbox.find(".lb-next").css("opacity", "1"))));
    }, Lightbox.prototype.updateDetails = function() {
        var self = this;
        if (// Enable anchor clicks in the injected caption html.
        // Thanks Nate Wright for the fix. @https://github.com/NateWr
        "undefined" != typeof this.album[this.currentImageIndex].title && "" !== this.album[this.currentImageIndex].title && this.$lightbox.find(".lb-caption").html(this.album[this.currentImageIndex].title).fadeIn("fast").find("a").on("click", function(event) {
            void 0 !== $(this).attr("target") ? window.open($(this).attr("href"), $(this).attr("target")) : location.href = $(this).attr("href");
        }), this.album.length > 1 && this.options.showImageNumberLabel) {
            var labelText = this.imageCountLabel(this.currentImageIndex + 1, this.album.length);
            this.$lightbox.find(".lb-number").text(labelText).fadeIn("fast");
        } else this.$lightbox.find(".lb-number").hide();
        this.$outerContainer.removeClass("animating"), this.$lightbox.find(".lb-dataContainer").fadeIn(this.options.resizeDuration, function() {
            return self.sizeOverlay();
        });
    }, Lightbox.prototype.preloadNeighboringImages = function() {
        if (this.album.length > this.currentImageIndex + 1) {
            var preloadNext = new Image();
            preloadNext.src = this.album[this.currentImageIndex + 1].link;
        }
        if (this.currentImageIndex > 0) {
            var preloadPrev = new Image();
            preloadPrev.src = this.album[this.currentImageIndex - 1].link;
        }
    }, Lightbox.prototype.enableKeyboardNav = function() {
        $(document).on("keyup.keyboard", $.proxy(this.keyboardAction, this));
    }, Lightbox.prototype.disableKeyboardNav = function() {
        $(document).off(".keyboard");
    }, Lightbox.prototype.keyboardAction = function(event) {
        var KEYCODE_ESC = 27, KEYCODE_LEFTARROW = 37, KEYCODE_RIGHTARROW = 39, keycode = event.keyCode, key = String.fromCharCode(keycode).toLowerCase();
        keycode === KEYCODE_ESC || key.match(/x|o|c/) ? this.end() : "p" === key || keycode === KEYCODE_LEFTARROW ? 0 !== this.currentImageIndex ? this.changeImage(this.currentImageIndex - 1) : this.options.wrapAround && this.album.length > 1 && this.changeImage(this.album.length - 1) : ("n" === key || keycode === KEYCODE_RIGHTARROW) && (this.currentImageIndex !== this.album.length - 1 ? this.changeImage(this.currentImageIndex + 1) : this.options.wrapAround && this.album.length > 1 && this.changeImage(0));
    }, Lightbox.prototype.end = function() {
        this.disableKeyboardNav(), $(window).off("resize", this.sizeOverlay), 
        this.$lightbox.fadeOut(this.options.fadeDuration), 
        this.$overlay.fadeOut(this.options.fadeDuration), 
        $("select, object, embed").css({
            visibility: "visible"
        }), this.options.disableScrolling && $("body").removeClass("lb-disable-scrolling");
    }, new Lightbox();
}), /**

	This script adds/removes class of the header and a button in the header changing
	the button and header styles once you scroll past a certain point
	
**/
$(function() {
    function headerBackground() {
        /**
			If window position is more or qual to 250 then shouldBeSticky is TRUE
		**/
        var windowPosition = $w.scrollTop(), shouldBeSticky = windowPosition >= 250;
        // If TRUE then add class .STICKY-HEADER to header
        shouldBeSticky ? (button.removeClass("btn-line"), 
        header.addClass("header-sticky")) : (button.addClass("btn-line"), 
        header.removeClass("header-sticky"));
    }
    // Variables
    var header = $("#header"), button = $("#header .btn"), $w = $(window);
    $(document).ready(headerBackground), $w.scroll(headerBackground);
}), /**

	This script makes a navigation menu a hamburger dropdown when the site is viewed on
	a mobile device

**/
function($) {
    $.fn.dropMenu = function(options) {
        // Options
        var cssmenu = $(this), settings = $.extend({
            title: "Menu",
            format: "dropdown"
        }, options);
        return this.each(function() {
            return cssmenu.prepend('<div id="menu-hamburger">' + settings.title + "</div>"), 
            $(this).find("#menu-hamburger").on("click", function() {
                $(this).toggleClass("menu-opened");
                // Define the menu
                var mainmenu = $(".navigation");
                mainmenu.hasClass("open") ? //mainmenu.hide().removeClass('open');
                mainmenu.slideToggle().removeClass("open") : (//mainmenu.show().addClass('open');
                mainmenu.slideToggle().addClass("open"), "dropdown" === settings.format && mainmenu.find("ul").show());
            }), resizeFix = function() {
                var breakpoint = 868;
                $(window).width() > breakpoint && cssmenu.find("ul").show(), 
                $(window).width() <= breakpoint && cssmenu.find("ul").hide().removeClass("open");
            }, resizeFix(), $(window).on("resize", resizeFix);
        });
    };
}(jQuery), function($) {
    $(document).ready(function() {
        $(".site-navigation").dropMenu({
            title: "Menu",
            format: "multitoggle"
        });
    });
}(jQuery), function($) {
    $.fn.unveil = function(threshold, callback) {
        function unveil() {
            var inview = images.filter(function() {
                var $e = $(this);
                if (!$e.is(":hidden")) {
                    var wt = $w.scrollTop(), wb = wt + $w.height(), et = $e.offset().top, eb = et + $e.height();
                    return eb >= wt - th && wb + th >= et;
                }
            });
            loaded = inview.trigger("unveil"), images = images.not(loaded);
        }
        var loaded, $w = $(window), th = threshold || 0, retina = window.devicePixelRatio > 1, attrib = retina ? "data-src-retina" : "data-src", images = this;
        return this.one("unveil", function() {
            var source = this.getAttribute(attrib);
            source = source || this.getAttribute("data-src"), 
            source && (this.setAttribute("src", source), "function" == typeof callback && callback.call(this));
        }), $w.on("scroll.unveil resize.unveil lookup.unveil", unveil), 
        unveil(), this;
    };
}(window.jQuery || window.Zepto);